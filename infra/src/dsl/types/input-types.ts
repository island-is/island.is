import { ServiceBuilder } from '../dsl'
import { FeatureNames } from '../features'
import { EnvironmentConfig } from './charts'
import { Optional } from './helpers'

export type OpsEnv = 'dev' | 'staging' | 'prod'
export type OpsEnvWithLocal = OpsEnv | 'local'
export const localFromDev = (env: OpsEnvWithLocal): OpsEnv =>
  env === 'local' ? 'dev' : env
export const MissingSetting = 'Missing setting'
export type MissingSettingType = typeof MissingSetting

// Input types
export type Hash = { [name: string]: Hash | string | number }
export type ValueSource = string | ((e: Context) => string)
export type ValueType = MissingSettingType | ValueSource
// See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes for more info
export type AccessModes = 'ReadWrite' | 'ReadOnly'

export type BffInfo = {
  key: PortalKeys
  clientId: string
  clientName: string
  services: BffInfraServices
  /**
   * Global url prefix for the app
   */
  globalPrefix: string
  env?: EnvironmentVariables
  secrets?: Secrets
}

export type PostgresInfo = {
  host?: {
    [env in OpsEnv]: string
  }
  name?: string
  username?: string
  passwordSecret?: string
  readOnly?: boolean
  extensions?: string[]
}
export type PostgresInfoForEnv = {
  host?: string
  name?: string
  username?: string
  passwordSecret?: string
  extensions?: string[]
}

export type RedisInfo = {
  host?: { [env in OpsEnv]: string }
}

export type RedisInfoForEnv = {
  host?: string
}

export type HealthProbe = {
  path: string
  initialDelaySeconds: number
  timeoutSeconds: number
}

export type Secrets = { [name: string]: string }

export type EnvironmentVariableValue =
  | Optional<
      {
        [idx in OpsEnvWithLocal]: ValueType
      },
      'local'
    >
  | ValueType

export type EnvironmentVariables = {
  [name: string]: EnvironmentVariableValue
}
export type EnvironmentVariablesForEnv = {
  [name: string]: ValueSource
}

export interface XroadConfig {
  getEnv(): EnvironmentVariables

  getSecrets(): Secrets
}

export type Feature = {
  env: EnvironmentVariables
  secrets: Secrets
}

export type Features = { [name in FeatureNames]: Feature }
export type MountedFile = { filename: string; env: string }
export type PortalKeys = 'stjornbord' | 'minarsidur'

export interface BffInfraServices {
  api: ServiceBuilder<string> | string
}

export type ServiceDefinitionCore = {
  liveness: HealthProbe
  readiness: HealthProbe
  healthPort?: number
  port?: number
  secrets: Secrets
  features: Partial<Features>
  namespace: string
  grantNamespaces: string[]
  grantNamespacesEnabled: boolean
  name: string
  accountName?: string
  serviceAccountEnabled: boolean
  cmds?: string
  args?: string[]
  image?: string
  resources: Resources
  replicaCount?: ReplicaCount
  securityContext: {
    privileged: boolean
    allowPrivilegeEscalation: boolean
  }
  files: MountedFile[]
  volumes: PersistentVolumeClaim[]
  podDisruptionBudget?: PodDisruptionBudget
}
export type IngressMapping = Partial<Record<string, Ingress>>
/**
 * This is the definition of a service as generated by ServiceBuilder.
 */
export type ServiceDefinition = ServiceDefinitionCore & {
  initContainers?: InitContainers
  env: EnvironmentVariables
  ingress: IngressMapping
  postgres?: PostgresInfo
  redis?: RedisInfo
  extraAttributes?: ExtraValues
  xroadConfig: XroadConfig[]
}

/**
 * This is a service definition for a specific environment, still independent of output type
 */
export type ServiceDefinitionForEnv = ServiceDefinitionCore & {
  initContainers?: InitContainersForEnv
  env: EnvironmentVariablesForEnv
  ingress: { [name: string]: IngressForEnv }
  postgres?: PostgresInfoForEnv
  redis?: RedisInfoForEnv
  extraAttributes?: ExtraValuesForEnv
}

export interface Ingress {
  host: {
    [env in OpsEnv]: string | string[]
  }
  paths: string[]
  public?: boolean
  extraAnnotations?: Partial<{
    [env in OpsEnv]: { [annotation: string]: string | null }
  }>
}

export interface IngressForEnv {
  host: string | string[]
  paths: string[]
  public?: boolean
  serviceUpstream?: boolean
  extraAnnotations?: { [idx: string]: string | null }
}

export type PodDisruptionBudget = {
  minAvailable?: number
  maxUnavailable?: number
}
export type PersistentVolumeClaim = {
  name?: string
  size: '1Gi' | '5Gi' | '10Gi' | string
  accessModes: AccessModes
  useExisting?: boolean
  mountPath: string
  /**
   * Sets the storageClass, leave empty if storageClass means little to you(defaults to efs-csi),
   * Mostly for internal use by the DevOps team.
   */
  storageClass?: string
}

export type Resources = {
  limits: {
    cpu: string
    memory: string
  }
  requests: {
    cpu: string
    memory: string
  }
}

export type ReplicaCount = {
  default: number
  max: number
  min: number
  /**
   * This is mostly for internal use by the DevOps team. If you would like to know more about it, please be in touch with them.
   * For more info, see this - https://prometheus.io/docs/prometheus/latest/querying/functions/#irate
   */
  scalingMagicNumber?: number
}

type Container = {
  command: string
  image?: string
  args?: string[]
  name?: string
  resources?: Resources
}

export type InitContainers = {
  envs: EnvironmentVariables
  secrets: Secrets
  features: Partial<Features>
  containers: Container[]
  /**
   * @deprecated Don't pass custom postgres info
   */
  postgres?: PostgresInfo
}
export type InitContainersForEnv = {
  envs: EnvironmentVariablesForEnv
  secrets: Secrets
  features: Partial<Features>
  containers: {
    command: string
    image?: string
    args?: string[]
    name?: string
    resources?: Resources
  }[]
  postgres?: PostgresInfoForEnv
}

export interface Context {
  featureDeploymentName?: string
  env: EnvironmentConfig

  svc(dep: ServiceBuilder<any> | string): string
}

export type ExtraValuesForEnv = Hash
export type ExtraValues = { [env in OpsEnv]: Hash | MissingSettingType }
