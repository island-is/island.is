import { FeatureNames } from '../features'
import { EnvironmentConfig } from './charts'
import { ServiceBuilder } from '../dsl'
import { Optional } from './helpers'

export type OpsEnv = 'dev' | 'staging' | 'prod'
export type OpsEnvWithLocal = OpsEnv | 'local'
export const localFromDev = (env: OpsEnvWithLocal): OpsEnv =>
  env === 'local' ? 'dev' : env
export const MissingSetting = 'Missing setting'
export type MissingSettingType = typeof MissingSetting

// Input types
export type Hash = { [name: string]: Hash | string | number }
export type ValueSource = string | ((e: Context) => string)
export type ValueType = MissingSettingType | ValueSource
// See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes for more info
export type AccessModes = 'ReadWrite' | 'ReadOnly'
export type PostgresInfo = {
  host?: {
    [idx in OpsEnv]: string
  }
  name?: string
  username?: string
  passwordSecret?: string
  extensions?: string[]
}
export type PostgresInfoForEnv = {
  host?: string
  name?: string
  username?: string
  passwordSecret?: string
  extensions?: string[]
}

export type RedisInfo = {
  host?: { [idx in OpsEnv]: string }
}

export type RedisInfoForEnv = {
  host?: string
}

export type HealthProbe = {
  path: string
  initialDelaySeconds: number
  timeoutSeconds: number
}

export type Secrets = { [name: string]: string }

export type EnvironmentVariableValue =
  | Optional<
      {
        [idx in OpsEnvWithLocal]: ValueType
      },
      'local'
    >
  | ValueType

export type EnvironmentVariables = {
  [name: string]: EnvironmentVariableValue
}
export type EnvironmentVariablesForEnv = {
  [name: string]: ValueSource
}

export interface XroadConfig {
  getEnv(): EnvironmentVariables

  getSecrets(): Secrets
}

export type Feature = {
  env: EnvironmentVariables
  secrets: Secrets
}

export type DockerImage = {
  name?: string
  repository?: string
  tag?: string
}

export type Features = { [name in FeatureNames]: Feature }
export type MountedFile = { filename: string; env: string }

export type ServiceDefinitionCore = {
  liveness: HealthProbe
  readiness: HealthProbe
  healthPort?: number
  port?: number
  secrets: Secrets
  features: Partial<Features>
  namespace: string
  grantNamespaces: string[]
  grantNamespacesEnabled: boolean
  name: string
  accountName?: string
  serviceAccountEnabled: boolean
  cmds?: string
  args?: string[]
  image?: DockerImage
  resources: Resources
  replicaCount?: ReplicaCount
  securityContext: {
    privileged: boolean
    allowPrivilegeEscalation: boolean
  }
  files: MountedFile[]
  volumes: PersistentVolumeClaim[]
}
/**
 * This is the definition of a service as generated by ServiceBuilder.
 */
export type ServiceDefinition = ServiceDefinitionCore & {
  initContainers?: InitContainers
  env: EnvironmentVariables
  ingress: { [name: string]: Ingress }
  postgres?: PostgresInfo
  redis?: RedisInfo
  extraAttributes?: ExtraValues
  xroadConfig: XroadConfig[]
  jobs?: Job
}

/**
 * This is a service definition for a specific environment, still independent of output type
 */
export type ServiceDefinitionForEnv = ServiceDefinitionCore & {
  initContainers?: InitContainersForEnv
  env: EnvironmentVariablesForEnv
  jobs?: JobForEnv
  ingress: { [name: string]: IngressForEnv }
  postgres?: PostgresInfoForEnv
  redis?: RedisInfoForEnv
  extraAttributes?: ExtraValuesForEnv
}

export interface Ingress {
  host: {
    [name in OpsEnv]: string | string[]
  }
  paths: string[]
  public?: boolean
  extraAnnotations?: { [name in OpsEnv]: { [idx: string]: string | null } }
}

export interface IngressForEnv {
  host: string | string[]
  paths: string[]
  public?: boolean
  serviceUpstream?: boolean
  extraAnnotations?: { [idx: string]: string | null }
}

export type PersistentVolumeClaim = {
  name?: string
  size: '1Gi' | '5Gi' | '10Gi' | string
  accessModes: AccessModes
  useExisting?: boolean
  mountPath: string
  /**
   * Sets the storageClass, leave empty if storageClass means little to you(defaults to efs-csi),
   * Mostly for internal use by the DevOps team.
   */
  storageClass?: string
}

export type Resources = {
  limits: {
    cpu: string
    memory: string
  }
  requests: {
    cpu: string
    memory: string
  }
}

export type ReplicaCount = {
  default: number
  max: number
  min: number
  /**
   * This is mostly for internal use by the DevOps team. If you would like to know more about it, please be in touch with them.
   * For more info, see this - https://prometheus.io/docs/prometheus/latest/querying/functions/#irate
   */
  scalingMagicNumber?: number
}

export type Container = {
  command: string
  image?: string
  args?: string[]
  name?: string
  resources?: Resources
}

export type InitContainers = {
  envs: EnvironmentVariables
  secrets: Secrets
  features: Partial<Features>
  containers: Container[]
  postgres?: PostgresInfo
}

export type InitContainersForEnv = {
  envs: EnvironmentVariablesForEnv
  secrets: Secrets
  features: Partial<Features>
  containers: Container[]
  postgres?: PostgresInfoForEnv
}

export type JobItem = {
  envs?: EnvironmentVariables
  secrets?: Secrets
  name: string
  backoffLimit?: number
  restartPolicy?: 'Never' | 'OnFailure'
  ttlSecondsAfterFinished?: number
  containers: Container[]
}

type EnvJobs = { [K in OpsEnv]?: JobItem[] }
type AtLeastOneEnvJob = {
  [K in OpsEnv]: EnvJobs[K] extends never ? never : JobItem[]
}
export type Job = AtLeastOneEnvJob | JobItem[]
export type JobForEnv = JobItem[]

export interface Context {
  featureDeploymentName?: string
  env: EnvironmentConfig

  svc(dep: ServiceBuilder<any> | string): string
}

export type ExtraValuesForEnv = Hash
export type ExtraValues = { [idx in OpsEnv]: Hash | MissingSettingType }
